"""
Run SAM segmentation on raster files using the segment-geospatial library
"""

import os
import json
import numpy as np
from PIL import Image
import geopandas as gpd
from shapely.geometry import Polygon, MultiPolygon
from typing import List, Dict, Tuple
import warnings
warnings.filterwarnings('ignore')

# Import the SAM-GEO library
from samgeo import SamGeo

class SAMBuildingSegmenter:
    def __init__(self, confidence_threshold: float = 0.6):
        self.confidence_threshold = confidence_threshold
        self.sam = SamGeo(model_type='vit_h', automatic=True)
        
    def pixel_to_geo(self, pixel_x: int, pixel_y: int, metadata: Dict) -> Tuple[float, float]:
        """Convert pixel coordinates to geographic coordinates"""
        bounds = metadata['bounds']
        width = metadata['width']
        height = metadata['height']
        
        # Calculate geographic coordinates
        lon = bounds['west'] + (pixel_x / width) * (bounds['east'] - bounds['west'])
        lat = bounds['north'] - (pixel_y / height) * (bounds['north'] - bounds['south'])
        
        return lat, lon
    
    def segment_buildings(self, image_path: str, metadata: Dict) -> List[Dict]:
        """
        Segment buildings from satellite imagery using SAM
        """
        try:
            # Generate masks using automatic mask generation
            self.sam.generate(
                source=image_path,
                output=None,  # Don't save to file
                foreground=True,
                erosion_kernel=(3, 3),
                mask_multiplier=255,
                unique=True,
                show=False,
                save=False
            )
            
            # Get the generated masks
            masks = self.sam.masks
            
            if masks is None or len(masks) == 0:
                print("  No masks generated by SAM")
                return self.fallback_segmentation(image_path, metadata)
            
            # Convert masks to building polygons
            building_polygons = []
            
            for i, mask in enumerate(masks):
                # Get mask properties
                area = mask.get('area', 0)
                stability_score = mask.get('stability_score', 0.5)
                predicted_iou = mask.get('predicted_iou', 0.5)
                
                # Filter based on confidence and area
                if predicted_iou < self.confidence_threshold:
                    continue
                    
                # Filter by area (buildings should be reasonably sized)
                if area < 100 or area > 1000000:  # Filter very small or very large areas
                    continue
                
                # Get the segmentation mask
                segmentation = mask.get('segmentation', None)
                if segmentation is None:
                    continue
                
                # Convert segmentation to polygon
                polygon = self.mask_to_polygon(segmentation, metadata)
                if polygon and polygon.is_valid:
                    # Calculate area in square meters
                    area_m2 = polygon.area * (111000)**2
                    
                    building_polygons.append({
                        'geometry': polygon,
                        'confidence': predicted_iou,
                        'area_m2': area_m2,
                        'stability_score': stability_score,
                        'building_id': i
                    })
            
            return building_polygons
            
        except Exception as e:
            print(f"  Error in SAM segmentation: {e}")
            # Fallback to simple segmentation if SAM fails
            return self.fallback_segmentation(image_path, metadata)
    
    def mask_to_polygon(self, mask: np.ndarray, metadata: Dict) -> Polygon:
        """Convert a binary mask to a geographic polygon"""
        try:
            import cv2
            
            # Find contours in the mask
            contours, _ = cv2.findContours(
                mask.astype(np.uint8), 
                cv2.RETR_EXTERNAL, 
                cv2.CHAIN_APPROX_SIMPLE
            )
            
            if not contours:
                return None
            
            # Use the largest contour
            largest_contour = max(contours, key=cv2.contourArea)
            
            # Simplify contour
            epsilon = 0.02 * cv2.arcLength(largest_contour, True)
            approx = cv2.approxPolyDP(largest_contour, epsilon, True)
            
            if len(approx) < 3:
                return None
            
            # Convert pixel coordinates to geographic coordinates
            geo_points = []
            for point in approx:
                pixel_x, pixel_y = point[0]
                lat, lon = self.pixel_to_geo(pixel_x, pixel_y, metadata)
                geo_points.append((lon, lat))
            
            if len(geo_points) < 3:
                return None
            
            return Polygon(geo_points)
            
        except Exception as e:
            print(f"    Error converting mask to polygon: {e}")
            return None
    
    def fallback_segmentation(self, image_path: str, metadata: Dict) -> List[Dict]:
        """Fallback segmentation using simple image processing"""
        try:
            import cv2
            
            # Load image
            image = Image.open(image_path)
            image_np = np.array(image)
            
            # Convert to grayscale
            gray = cv2.cvtColor(image_np, cv2.COLOR_RGB2GRAY)
            
            # Apply edge detection and morphological operations
            edges = cv2.Canny(gray, 50, 150)
            kernel = np.ones((5, 5), np.uint8)
            closed = cv2.morphologyEx(edges, cv2.MORPH_CLOSE, kernel)
            
            # Find contours
            contours, _ = cv2.findContours(closed, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
            
            building_polygons = []
            h, w = image_np.shape[:2]
            
            for i, contour in enumerate(contours):
                area = cv2.contourArea(contour)
                if area < 500:  # Filter small areas
                    continue
                
                # Approximate polygon
                epsilon = 0.02 * cv2.arcLength(contour, True)
                approx = cv2.approxPolyDP(contour, epsilon, True)
                
                if len(approx) < 3:
                    continue
                
                # Convert to geographic coordinates
                geo_points = []
                for point in approx:
                    pixel_x, pixel_y = point[0]
                    lat, lon = self.pixel_to_geo(pixel_x, pixel_y, metadata)
                    geo_points.append((lon, lat))
                
                if len(geo_points) < 3:
                    continue
                
                try:
                    polygon = Polygon(geo_points)
                    if polygon.is_valid and polygon.area > 0:
                        area_m2 = polygon.area * (111000)**2
                        
                        # Simple confidence based on area and shape
                        perimeter = cv2.arcLength(contour, True)
                        circularity = 4 * np.pi * area / (perimeter ** 2) if perimeter > 0 else 0
                        confidence = min(0.5 + circularity * 0.3 + min(area / 50000, 0.2), 0.95)
                        
                        if confidence >= self.confidence_threshold:
                            building_polygons.append({
                                'geometry': polygon,
                                'confidence': confidence,
                                'area_m2': area_m2,
                                'stability_score': confidence * 0.9,
                                'building_id': i
                            })
                except Exception as e:
                    continue
            
            return building_polygons
            
        except Exception as e:
            print(f"  Error in fallback segmentation: {e}")
            return []

def process_building_raster(raster_path: str, metadata: Dict, output_dir: str) -> int:
    """Process a single raster file and save building polygons"""
    building_id = os.path.basename(raster_path).replace('.png', '')
    
    # Initialize segmenter
    segmenter = SAMBuildingSegmenter(confidence_threshold=0.6)
    
    print(f"  Running SAM segmentation on {os.path.basename(raster_path)}")
    
    try:
        # Segment buildings
        building_polygons = segmenter.segment_buildings(raster_path, metadata)
        
        if not building_polygons:
            print(f"  ✗ No buildings found")
            return 0
        
        # Filter by confidence
        filtered_polygons = [p for p in building_polygons if p['confidence'] >= 0.6]
        
        print(f"  Found {len(building_polygons)} potential buildings")
        print(f"  {len(filtered_polygons)} buildings above confidence threshold")
        
        if not filtered_polygons:
            print(f"  ✗ No buildings above confidence threshold")
            return 0
        
        # Create GeoDataFrame
        gdf = gpd.GeoDataFrame([{
            'geometry': p['geometry'],
            'confidence': p['confidence'],
            'area_m2': p['area_m2'],
            'stability_score': p['stability_score'],
            'building_id': p['building_id']
        } for p in filtered_polygons])
        
        # Set CRS to WGS84
        gdf.crs = 'EPSG:4326'
        
        # Save as shapefile
        shapefile_path = os.path.join(output_dir, f'{building_id}.shp')
        gdf.to_file(shapefile_path)
        
        # Also save as GeoJSON
        geojson_path = os.path.join(output_dir, f'{building_id}.geojson')
        gdf.to_file(geojson_path, driver='GeoJSON')
        
        print(f"  ✓ Saved {len(filtered_polygons)} buildings to shapefile")
        return len(filtered_polygons)
        
    except Exception as e:
        print(f"  ✗ Error processing {building_id}: {e}")
        return 0

def main():
    """Process all raster files with SAM segmentation"""
    # Create output directory
    output_dir = 'data/shapefiles'
    os.makedirs(output_dir, exist_ok=True)
    
    # Load raster metadata
    metadata_path = 'data/metadata/raster_metadata.json'
    if not os.path.exists(metadata_path):
        print(f"Error: Metadata file not found: {metadata_path}")
        return
    
    with open(metadata_path, 'r') as f:
        all_metadata = json.load(f)
    
    # Get all raster files
    raster_dir = 'data/rasters'
    raster_files = [f for f in os.listdir(raster_dir) if f.endswith('.png')]
    raster_files.sort()
    
    print(f"Found {len(raster_files)} raster files to process")
    print("=" * 50)
    
    # Process each raster
    total_buildings = 0
    processed_files = 0
    
    for raster_file in raster_files:
        building_id = raster_file.replace('.png', '')
        
        print(f"\nProcessing {building_id}")
        
        # Get metadata
        if building_id not in all_metadata:
            print(f"  ✗ No metadata found for {building_id}")
            continue
        
        metadata = all_metadata[building_id]
        raster_path = os.path.join(raster_dir, raster_file)
        
        # Process raster
        building_count = process_building_raster(raster_path, metadata, output_dir)
        
        if building_count > 0:
            total_buildings += building_count
            processed_files += 1
    
    print("\n" + "=" * 50)
    print(f"Processing complete!")
    print(f"Files processed: {processed_files}")
    print(f"Total buildings found: {total_buildings}")
    print(f"Average buildings per file: {total_buildings/max(processed_files, 1):.1f}")

# Test cases
if __name__ == "__main__":
    # Test 1: Initialize SAM segmenter
    print("Test 1: Initialize SAM segmenter")
    try:
        segmenter = SAMBuildingSegmenter()
        print("  ✓ SAM segmenter initialized successfully")
    except Exception as e:
        print(f"  ✗ SAM segmenter initialization failed: {e}")
    
    # Test 2: Test coordinate conversion
    print("\nTest 2: Coordinate conversion")
    test_metadata = {
        'bounds': {'north': 37.776, 'south': 37.774, 'east': -122.418, 'west': -122.420},
        'width': 512,
        'height': 256
    }
    
    segmenter = SAMBuildingSegmenter()
    lat, lon = segmenter.pixel_to_geo(0, 0, test_metadata)
    print(f"  Pixel (0, 0) -> Geo ({lon:.6f}, {lat:.6f})")
    
    lat, lon = segmenter.pixel_to_geo(256, 128, test_metadata)
    print(f"  Pixel (256, 128) -> Geo ({lon:.6f}, {lat:.6f})")
    
    # Test 3: Process test raster (if available)
    print("\nTest 3: Process test raster")
    test_raster = 'data/test/test_raster.png'
    if os.path.exists(test_raster):
        try:
            building_count = process_building_raster(test_raster, test_metadata, 'data/test')
            print(f"  Processed test raster: {building_count} buildings found")
        except Exception as e:
            print(f"  Error processing test raster: {e}")
    else:
        print("  Test raster not found, skipping")
    
    # Run main pipeline
    print("\n" + "=" * 50)
    print("Running main pipeline...")
    print("=" * 50)
    main()